import React, { createContext, useContext, useState, useEffect } from 'react'

// Task status enum
export const TaskStatus = {
  NOT_STARTED: 'not_started',
  IN_PROGRESS: 'in_progress',
  COMPLETED: 'completed',
  BLOCKED: 'blocked'
}

// Task priority enum
export const TaskPriority = {
  LOW: 'low',
  MEDIUM: 'medium',
  HIGH: 'high',
  CRITICAL: 'critical'
}

// 30 SUPER DETAILED TASKS - Consolidated from 80+ tasks into comprehensive game progression
// Each task has 15-25 detailed subtasks covering all aspects of implementation
const DEFAULT_TASKS = {
  // Level 1: Foundation
  Level1_ProjectSetup: {
    id: 'Level1_ProjectSetup',
    title: 'ðŸŽ® Level 1: Project Foundation',
    description: 'Set up NestJS project from scratch with all core dependencies, project structure, environment configuration, Swagger documentation, and development tools.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.CRITICAL,
    category: 'Infrastructure',
    estimatedHours: 12,
    actualHours: 0,
    subtasks: [
      { id: 'nest-cli', title: 'Install NestJS CLI globally', completed: false },
      { id: 'nest-init', title: 'Initialize new NestJS project', completed: false },
      { id: 'nest-packages', title: 'Install core packages (TypeORM, JWT, Passport, Swagger, validation)', completed: false },
      { id: 'nest-structure', title: 'Setup module structure (modules, common, config folders)', completed: false },
      { id: 'nest-config', title: 'Environment configuration with @nestjs/config', completed: false },
      { id: 'nest-swagger', title: 'Swagger/OpenAPI setup and configuration', completed: false },
      { id: 'nest-validation', title: 'Global validation pipe setup', completed: false },
      { id: 'nest-exception', title: 'Global exception filter setup', completed: false },
      { id: 'nest-logging', title: 'Logging configuration', completed: false },
      { id: 'nest-testing', title: 'Testing setup (Jest configuration)', completed: false }
    ],
    notes: [],
    dependencies: [],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 2: Database & Authentication
  Level2_DatabaseAuth: {
    id: 'Level2_DatabaseAuth',
    title: 'ðŸŽ® Level 2: Database & Authentication',
    description: 'Set up TypeORM with all 81 entities, create database migrations, configure authentication with JWT, guards, RBAC, 2FA, and OTP support.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.CRITICAL,
    category: 'Infrastructure',
    estimatedHours: 104,
    actualHours: 0,
    subtasks: [
      // Database Setup
      { id: 'db-config', title: 'TypeORM configuration and connection setup', completed: false },
      { id: 'db-entities-identity', title: 'Identity entities (Customer, Admin, Role, Privilege, CustomerRole)', completed: false },
      { id: 'db-entities-assets', title: 'Asset entities (Coin, Network, Market, MarketPrice)', completed: false },
      { id: 'db-entities-trading', title: 'Trading entities (Order, Trade, OrderBook, TradeHistory)', completed: false },
      { id: 'db-entities-wallet', title: 'Wallet entities (HDWallet, CustomerWallet, WalletAddress, Transaction)', completed: false },
      { id: 'db-entities-finance', title: 'Finance entities (Deposit, Withdrawal, Transaction, Balance)', completed: false },
      { id: 'db-entities-payment', title: 'Payment gateway entities (PaymentGatewayTransaction, Settlement)', completed: false },
      { id: 'db-entities-kyc', title: 'KYC entities (KYCSubmission, KYCDocument, KYCStatus)', completed: false },
      { id: 'db-entities-other', title: 'Other entities (GiftCode, ReferralCode, Ticket, BlogPost, Notification, etc.)', completed: false },
      { id: 'db-relationships', title: 'Define all entity relationships (OneToMany, ManyToOne, ManyToMany)', completed: false },
      { id: 'db-indexes', title: 'Create indexes for performance (foreign keys, search fields)', completed: false },
      { id: 'db-constraints', title: 'Add constraints (unique, check, foreign key)', completed: false },
      { id: 'db-migrations', title: 'Generate and test database migrations', completed: false },
      { id: 'db-seeding', title: 'Create seed data (roles, privileges, initial coins, markets)', completed: false },
      // Auth Module
      { id: 'auth-module', title: 'Create auth module structure', completed: false },
      { id: 'auth-jwt', title: 'JWT strategy and token generation', completed: false },
      { id: 'auth-jwt-validate', title: 'JWT token validation and refresh', completed: false },
      { id: 'auth-guards', title: 'Authentication guards (JwtAuthGuard)', completed: false },
      { id: 'auth-rbac', title: 'RBAC decorators (@Roles, @Privileges)', completed: false },
      { id: 'auth-rbac-guard', title: 'RBAC guard implementation', completed: false },
      { id: 'auth-2fa', title: '2FA module (TOTP, Google Authenticator)', completed: false },
      { id: 'auth-otp', title: 'OTP generation and verification', completed: false },
      { id: 'auth-password', title: 'Password hashing with bcrypt', completed: false },
      { id: 'auth-session', title: 'Session management and tracking', completed: false },
      { id: 'auth-logout', title: 'Logout and token invalidation', completed: false }
    ],
    notes: [],
    dependencies: ['Level1_ProjectSetup'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 3: Core Services - Customer & Identity
  Level3_CustomerIdentity: {
    id: 'Level3_CustomerIdentity',
    title: 'ðŸŽ® Level 3: Customer & Identity Management',
    description: 'Build customer service with registration, authentication, KYC orchestration, profile management, and customer controller with all endpoints.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.CRITICAL,
    category: 'Services',
    estimatedHours: 52,
    actualHours: 0,
    subtasks: [
      // CustomerService
      { id: 'customer-entity', title: 'Create Customer entity with all fields', completed: false },
      { id: 'customer-register', title: 'User registration logic with validation', completed: false },
      { id: 'customer-auth', title: 'Authentication logic (login, token generation)', completed: false },
      { id: 'customer-password', title: 'Password management (hash, reset, change)', completed: false },
      { id: 'customer-kyc', title: 'KYC submission logic and document handling', completed: false },
      { id: 'customer-kyc-provider', title: 'Integration with KYC providers (FinnoTech, Jibit)', completed: false },
      { id: 'customer-2fa', title: '2FA implementation (TOTP, Google Authenticator)', completed: false },
      { id: 'customer-profile', title: 'Profile management (update, view)', completed: false },
      { id: 'customer-status', title: 'Account status management (active, suspended, etc.)', completed: false },
      { id: 'customer-otp', title: 'OTP generation and verification', completed: false },
      { id: 'customer-email', title: 'Email verification and management', completed: false },
      { id: 'customer-notification', title: 'User notification management', completed: false },
      // CustomerController
      { id: 'cust-module', title: 'Create customer module structure', completed: false },
      { id: 'cust-register', title: 'User registration endpoint with validation', completed: false },
      { id: 'cust-login', title: 'Login endpoint with JWT token generation', completed: false },
      { id: 'cust-otp', title: 'OTP generation and verification endpoints', completed: false },
      { id: 'cust-google', title: 'Google SSO integration endpoints', completed: false },
      { id: 'cust-kyc', title: 'KYC document submission endpoints', completed: false },
      { id: 'cust-2fa', title: '2FA setup, enable, and verification endpoints', completed: false },
      { id: 'cust-profile', title: 'Profile management endpoints (update, view)', completed: false },
      { id: 'cust-password', title: 'Password reset and change endpoints', completed: false },
      { id: 'cust-dto', title: 'Create DTOs for all customer operations', completed: false }
    ],
    notes: [],
    dependencies: ['Level2_DatabaseAuth'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 4: Notification Services
  Level4_Notifications: {
    id: 'Level4_Notifications',
    title: 'ðŸŽ® Level 4: Notification Services',
    description: 'Build EmailService, SMSService, and NotificationService for user communications, OTP delivery, alerts, and in-app notifications.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.HIGH,
    category: 'Services',
    estimatedHours: 24,
    actualHours: 0,
    subtasks: [
      { id: 'email-service', title: 'EmailService - SMTP integration and email templates', completed: false },
      { id: 'email-templates', title: 'Email templates (welcome, OTP, password reset, etc.)', completed: false },
      { id: 'sms-service', title: 'SMSService - SMS provider integration', completed: false },
      { id: 'sms-otp', title: 'SMS OTP delivery functionality', completed: false },
      { id: 'notification-service', title: 'NotificationService - in-app notification management', completed: false },
      { id: 'notification-entity', title: 'Notification entity and repository', completed: false },
      { id: 'notification-create', title: 'Create notification logic', completed: false },
      { id: 'notification-read', title: 'Mark as read functionality', completed: false },
      { id: 'notification-push', title: 'Push notification support (optional)', completed: false },
      { id: 'notification-tests', title: 'Write tests for notification services', completed: false }
    ],
    notes: [],
    dependencies: ['Level2_DatabaseAuth'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 5: Wallet Services
  Level5_WalletServices: {
    id: 'Level5_WalletServices',
    title: 'ðŸŽ® Level 5: Wallet Services',
    description: 'Build WalletService, CustomerWalletService, DepositService, and WithdrawalService for HD wallet management, balance operations, deposits, and withdrawals.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.CRITICAL,
    category: 'Services',
    estimatedHours: 64,
    actualHours: 0,
    subtasks: [
      // WalletService
      { id: 'wallet-entity', title: 'Create HD wallet and address entities', completed: false },
      { id: 'wallet-hd-create', title: 'HD wallet creation with BIP32/BIP44', completed: false },
      { id: 'wallet-mnemonic', title: 'Mnemonic phrase generation and storage', completed: false },
      { id: 'wallet-address-gen', title: 'Multi-chain address generation (ETH, TRON, BTC, etc.)', completed: false },
      { id: 'wallet-tx-create', title: 'Transaction creation and signing', completed: false },
      { id: 'wallet-tx-broadcast', title: 'Transaction broadcasting to blockchain', completed: false },
      { id: 'wallet-withdrawal', title: 'Withdrawal request processing and validation', completed: false },
      { id: 'wallet-balance', title: 'Balance queries (on-chain and custodial)', completed: false },
      { id: 'wallet-security', title: 'Password encryption and key management', completed: false },
      { id: 'wallet-sweep', title: 'Wallet sweep functionality for hot wallets', completed: false },
      { id: 'wallet-multichain', title: 'Multi-chain support implementation', completed: false },
      // CustomerWalletService
      { id: 'cust-wallet-entity', title: 'CustomerWallet entity and repository', completed: false },
      { id: 'cust-wallet-balance', title: 'Get balance logic for all coins', completed: false },
      { id: 'cust-wallet-update', title: 'Update balance logic (credit/debit)', completed: false },
      { id: 'cust-wallet-lock', title: 'Lock/unlock funds for orders', completed: false },
      { id: 'cust-wallet-transfer', title: 'Internal transfer logic', completed: false },
      // DepositService
      { id: 'deposit-entity', title: 'DepositRequest entity', completed: false },
      { id: 'deposit-track', title: 'Track deposit logic', completed: false },
      { id: 'deposit-confirm', title: 'Confirm deposit and credit balance', completed: false },
      { id: 'deposit-webhook', title: 'Deposit webhook handling', completed: false },
      // WithdrawalService
      { id: 'withdraw-entity', title: 'WithdrawalRequest entity', completed: false },
      { id: 'withdraw-create', title: 'Create withdrawal request logic', completed: false },
      { id: 'withdraw-approve', title: 'Approve withdrawal logic', completed: false },
      { id: 'withdraw-reject', title: 'Reject withdrawal logic', completed: false },
      { id: 'withdraw-process', title: 'Process withdrawal (create blockchain tx)', completed: false }
    ],
    notes: [],
    dependencies: ['Level2_DatabaseAuth', 'Level6_Blockchain'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 6: Blockchain Integration
  Level6_Blockchain: {
    id: 'Level6_Blockchain',
    title: 'ðŸŽ® Level 6: Blockchain Integration',
    description: 'Build ApieService for multi-chain blockchain integration supporting ETH, TRON, XRP, XLM, BTC, BSC, Dash, and Stellar networks.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.CRITICAL,
    category: 'Services',
    estimatedHours: 32,
    actualHours: 0,
    subtasks: [
      { id: 'apie-http-client', title: 'HTTP client setup with retry logic', completed: false },
      { id: 'apie-config', title: 'Multi-chain configuration management', completed: false },
      { id: 'apie-wallet', title: 'Wallet operations (create, import, export)', completed: false },
      { id: 'apie-tx', title: 'Transaction operations (create, sign, broadcast)', completed: false },
      { id: 'apie-balance', title: 'Balance queries for all supported chains', completed: false },
      { id: 'apie-tx-status', title: 'Transaction status tracking', completed: false },
      { id: 'apie-eth', title: 'Ethereum (ETH) chain integration', completed: false },
      { id: 'apie-tron', title: 'TRON (TRX) chain integration', completed: false },
      { id: 'apie-btc', title: 'Bitcoin (BTC) chain integration', completed: false },
      { id: 'apie-bsc', title: 'Binance Smart Chain (BSC) integration', completed: false },
      { id: 'apie-xrp', title: 'XRP chain integration', completed: false },
      { id: 'apie-xlm', title: 'Stellar (XLM) chain integration', completed: false },
      { id: 'apie-dash', title: 'Dash chain integration', completed: false },
      { id: 'apie-webhook', title: 'Webhook handling for blockchain events', completed: false },
      { id: 'apie-error', title: 'Error handling and retry mechanisms', completed: false }
    ],
    notes: [],
    dependencies: ['Level2_DatabaseAuth'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 7: Trading Engine
  Level7_TradingEngine: {
    id: 'Level7_TradingEngine',
    title: 'ðŸŽ® Level 7: Trading Engine',
    description: 'Build OrderService and TradeService - the core trading engine with order matching, trade execution, order book management, and trade history.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.CRITICAL,
    category: 'Services',
    estimatedHours: 68,
    actualHours: 0,
    subtasks: [
      // OrderService
      { id: 'order-entity', title: 'Create Order entity with all fields', completed: false },
      { id: 'order-create-logic', title: 'Order creation and validation logic', completed: false },
      { id: 'order-matching', title: 'In-memory order matching engine (price-time priority)', completed: false },
      { id: 'order-book', title: 'Order book data structure (bids/asks)', completed: false },
      { id: 'order-validation', title: 'Price, amount, and balance validation', completed: false },
      { id: 'order-balance', title: 'Balance locking/unlocking mechanism', completed: false },
      { id: 'order-queue', title: 'Order queue management (pending orders)', completed: false },
      { id: 'order-stop-limit', title: 'Stop-limit order trigger logic', completed: false },
      { id: 'order-expiration', title: 'Order expiration and cleanup logic', completed: false },
      { id: 'order-persistence', title: 'Order persistence to database', completed: false },
      { id: 'order-scheduled', title: 'Scheduled tasks (expiration, cleanup, triggers)', completed: false },
      { id: 'order-trade-coord', title: 'Trade execution coordination', completed: false },
      // TradeService
      { id: 'trade-entity', title: 'Create Trade entity with all fields', completed: false },
      { id: 'trade-execute', title: 'Trade execution logic and coordination', completed: false },
      { id: 'trade-settlement', title: 'Trade settlement and balance updates', completed: false },
      { id: 'trade-history', title: 'Trade history queries with filtering', completed: false },
      { id: 'trade-pagination', title: 'Pagination and sorting for trade history', completed: false },
      { id: 'trade-stats', title: 'Trade statistics calculation (volume, P/L, win rate)', completed: false },
      { id: 'trade-aggregation', title: 'Trade data aggregation (daily, weekly, monthly)', completed: false },
      { id: 'trade-export', title: 'Trade history export functionality', completed: false },
      { id: 'trade-notification', title: 'Trade execution notifications', completed: false }
    ],
    notes: [],
    dependencies: ['Level5_WalletServices', 'Level8_MarketManagement'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 8: Market & Coin Management
  Level8_MarketManagement: {
    id: 'Level8_MarketManagement',
    title: 'ðŸŽ® Level 8: Market & Coin Management',
    description: 'Build MarketService, CoinService, MarketController, and CoinController for trading pair management, coin management, and price updates.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.HIGH,
    category: 'Services',
    estimatedHours: 36,
    actualHours: 0,
    subtasks: [
      // MarketService
      { id: 'market-entity', title: 'Create Market entity with all fields', completed: false },
      { id: 'market-crud', title: 'Market CRUD operations', completed: false },
      { id: 'market-activation', title: 'Market activation/deactivation logic', completed: false },
      { id: 'market-stats', title: 'Market statistics calculation (24h volume, price change)', completed: false },
      { id: 'market-price', title: 'Price update and management logic', completed: false },
      { id: 'market-pair', title: 'Trading pair configuration and validation', completed: false },
      { id: 'market-status', title: 'Market status management', completed: false },
      { id: 'market-scheduled', title: 'Scheduled tasks for price updates', completed: false },
      { id: 'market-cache', title: 'Market data caching for performance', completed: false },
      // CoinService
      { id: 'coin-entity', title: 'Create Coin and Network entities', completed: false },
      { id: 'coin-crud', title: 'Coin CRUD operations', completed: false },
      { id: 'coin-pricing', title: 'Price management and updates from external APIs', completed: false },
      { id: 'coin-price-scheduled', title: 'Scheduled tasks for price updates', completed: false },
      { id: 'coin-networks', title: 'Network and blockchain integration', completed: false },
      { id: 'coin-activation', title: 'Coin activation/deactivation logic', completed: false },
      { id: 'coin-config', title: 'Coin configuration management', completed: false },
      { id: 'coin-validation', title: 'Coin data validation', completed: false },
      { id: 'coin-cache', title: 'Coin price caching', completed: false },
      // Controllers
      { id: 'market-controller', title: 'MarketController with all endpoints', completed: false },
      { id: 'coin-controller', title: 'CoinController with all endpoints', completed: false }
    ],
    notes: [],
    dependencies: ['Level2_DatabaseAuth'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 9: Trading Controllers
  Level9_TradingControllers: {
    id: 'Level9_TradingControllers',
    title: 'ðŸŽ® Level 9: Trading Controllers',
    description: 'Build OrderController and TradeController with all trading endpoints, order book API, trade history, and real-time updates.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.CRITICAL,
    category: 'Controllers',
    estimatedHours: 36,
    actualHours: 0,
    subtasks: [
      // OrderController
      { id: 'order-module', title: 'Create order module structure', completed: false },
      { id: 'order-create-buy', title: 'Create buy order endpoint (market & limit)', completed: false },
      { id: 'order-create-sell', title: 'Create sell order endpoint (market & limit)', completed: false },
      { id: 'order-stop-limit', title: 'Stop-limit order endpoints', completed: false },
      { id: 'order-cancel', title: 'Cancel order endpoint with validation', completed: false },
      { id: 'order-book', title: 'Get order book endpoint (bids/asks)', completed: false },
      { id: 'order-history', title: 'Get user order history endpoint', completed: false },
      { id: 'order-status', title: 'Get order status endpoint', completed: false },
      { id: 'order-validation', title: 'DTO validation pipes and guards', completed: false },
      { id: 'order-websocket', title: 'WebSocket for real-time order updates', completed: false },
      { id: 'order-dto', title: 'Create comprehensive DTOs', completed: false },
      // TradeController
      { id: 'trade-module', title: 'Create trade module structure', completed: false },
      { id: 'trade-history', title: 'Get user trade history endpoint with pagination', completed: false },
      { id: 'trade-market', title: 'Market trade history endpoint (public)', completed: false },
      { id: 'trade-details', title: 'Get trade details endpoint', completed: false },
      { id: 'trade-stats', title: 'Get trade statistics endpoint (user)', completed: false },
      { id: 'trade-admin', title: 'Admin trade list endpoint with filters', completed: false },
      { id: 'trade-export', title: 'Export trade history to Excel endpoint', completed: false },
      { id: 'trade-websocket', title: 'WebSocket for real-time trade updates', completed: false },
      { id: 'trade-dto', title: 'Create DTOs for trade operations', completed: false }
    ],
    notes: [],
    dependencies: ['Level7_TradingEngine'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 10: Wallet Controller
  Level10_WalletController: {
    id: 'Level10_WalletController',
    title: 'ðŸŽ® Level 10: Wallet Controller',
    description: 'Build WalletController with HD wallet creation, address generation, withdrawal requests, balance queries, and transaction history endpoints.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.CRITICAL,
    category: 'Controllers',
    estimatedHours: 16,
    actualHours: 0,
    subtasks: [
      { id: 'wallet-module', title: 'Create wallet module structure', completed: false },
      { id: 'wallet-create', title: 'Create HD wallet endpoint with mnemonic generation', completed: false },
      { id: 'wallet-address', title: 'Generate address endpoint (multi-chain support)', completed: false },
      { id: 'wallet-address-list', title: 'List user addresses endpoint', completed: false },
      { id: 'wallet-withdrawal', title: 'Withdrawal request endpoint with validation', completed: false },
      { id: 'wallet-withdrawal-list', title: 'List withdrawal history endpoint', completed: false },
      { id: 'wallet-balance', title: 'Balance query endpoint (all coins)', completed: false },
      { id: 'wallet-transactions', title: 'Transaction history endpoint', completed: false },
      { id: 'wallet-deposit', title: 'Deposit address management endpoint', completed: false },
      { id: 'wallet-security', title: 'Wallet security operations (password change, etc.)', completed: false },
      { id: 'wallet-dto', title: 'Create comprehensive DTOs', completed: false }
    ],
    notes: [],
    dependencies: ['Level5_WalletServices'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 11: Payment Gateways
  Level11_PaymentGateways: {
    id: 'Level11_PaymentGateways',
    title: 'ðŸŽ® Level 11: Payment Gateway Integration',
    description: 'Build PaymentGateway service with integrations for Vandar, Jibit, NextPay, RayanPay, Sadad, and Zarinpal. Handle deposits, withdrawals, callbacks, and settlements.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.HIGH,
    category: 'Services',
    estimatedHours: 40,
    actualHours: 0,
    subtasks: [
      { id: 'gateway-interface', title: 'Create IPaymentGateway interface', completed: false },
      { id: 'gateway-factory', title: 'Gateway factory pattern implementation', completed: false },
      { id: 'gateway-vandar', title: 'Vandar integration (deposit, withdrawal, callback)', completed: false },
      { id: 'gateway-jibit', title: 'Jibit integration (deposit, withdrawal, callback)', completed: false },
      { id: 'gateway-nextpay', title: 'NextPay integration (deposit, withdrawal, callback)', completed: false },
      { id: 'gateway-rayanpay', title: 'RayanPay integration', completed: false },
      { id: 'gateway-sadad', title: 'Sadad integration', completed: false },
      { id: 'gateway-zarinpal', title: 'Zarinpal integration', completed: false },
      { id: 'gateway-callback', title: 'Unified callback handler for all gateways', completed: false },
      { id: 'gateway-verification', title: 'Callback signature verification', completed: false },
      { id: 'gateway-withdrawal', title: 'Withdrawal to bank account processing', completed: false },
      { id: 'gateway-settlement', title: 'Settlement reconciliation logic', completed: false },
      { id: 'gateway-tracking', title: 'Transaction tracking and status management', completed: false },
      { id: 'gateway-error', title: 'Error handling and retry mechanisms', completed: false }
    ],
    notes: [],
    dependencies: ['Level5_WalletServices'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 12: KYC & Identity Services
  Level12_KYCIdentity: {
    id: 'Level12_KYCIdentity',
    title: 'ðŸŽ® Level 12: KYC & Identity Services',
    description: 'Build FinoTechService, JibitService (KYC), BankAccountService, and UserAccountLevelService for identity verification and KYC processing.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.HIGH,
    category: 'Services',
    estimatedHours: 32,
    actualHours: 0,
    subtasks: [
      { id: 'finnotech-service', title: 'FinoTechService - National ID validation, card to IBAN, bank account verification', completed: false },
      { id: 'jibit-kyc', title: 'JibitService KYC - IBAN matching, card matching, identity similarity', completed: false },
      { id: 'bank-account-service', title: 'BankAccountService - Bank account management and validation', completed: false },
      { id: 'account-level-service', title: 'UserAccountLevelService - Account level management (USER, AUTHORIZED_USER)', completed: false },
      { id: 'kyc-entity', title: 'KYC entity structures and repositories', completed: false },
      { id: 'kyc-workflow', title: 'KYC workflow orchestration', completed: false },
      { id: 'kyc-admin-review', title: 'Admin review interface integration', completed: false },
      { id: 'kyc-status-tracking', title: 'KYC status tracking and updates', completed: false }
    ],
    notes: [],
    dependencies: ['Level3_CustomerIdentity'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 13: Admin & RBAC
  Level13_AdminRBAC: {
    id: 'Level13_AdminRBAC',
    title: 'ðŸŽ® Level 13: Admin & RBAC Management',
    description: 'Build AdminService, RoleService, AdminController, and RolesController for admin user management, RBAC, system configuration, and administrative operations.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.HIGH,
    category: 'Services',
    estimatedHours: 28,
    actualHours: 0,
    subtasks: [
      // AdminService
      { id: 'admin-entity', title: 'Create Admin entity with all fields', completed: false },
      { id: 'admin-crud', title: 'Admin CRUD operations', completed: false },
      { id: 'admin-auth', title: 'Admin authentication logic', completed: false },
      { id: 'admin-rbac', title: 'RBAC integration and privilege checking', completed: false },
      { id: 'admin-user-mgmt', title: 'User management operations (suspend, activate, etc.)', completed: false },
      { id: 'admin-config', title: 'System configuration management', completed: false },
      { id: 'admin-monitoring', title: 'System monitoring and statistics', completed: false },
      { id: 'admin-reporting', title: 'Administrative reporting functionality', completed: false },
      { id: 'admin-audit', title: 'Admin action audit logging', completed: false },
      // RoleService
      { id: 'role-entity', title: 'Create Role, Privilege, and RolePrivilege entities', completed: false },
      { id: 'role-crud', title: 'Role CRUD operations', completed: false },
      { id: 'role-privileges', title: 'Privilege management (CRUD, assignment)', completed: false },
      { id: 'role-assignment', title: 'Role assignment logic (users, admins)', completed: false },
      { id: 'role-checking', title: 'Privilege checking logic', completed: false },
      { id: 'role-hierarchy', title: 'Role hierarchy support (optional)', completed: false },
      { id: 'role-validation', title: 'Permission validation for access control', completed: false },
      { id: 'role-seeding', title: 'Initial roles and privileges seeding', completed: false },
      // Controllers
      { id: 'admin-controller', title: 'AdminController with all endpoints', completed: false },
      { id: 'roles-controller', title: 'RolesController with all endpoints', completed: false }
    ],
    notes: [],
    dependencies: ['Level2_DatabaseAuth'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 14: OTC Exchange
  Level14_OTCExchange: {
    id: 'Level14_OTCExchange',
    title: 'ðŸŽ® Level 14: OTC Exchange',
    description: 'Build ExchangeActionService and ExchangeActionController for over-the-counter exchange operations with buy/sell orders and admin approval workflow.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.HIGH,
    category: 'Services',
    estimatedHours: 24,
    actualHours: 0,
    subtasks: [
      { id: 'exchange-service', title: 'ExchangeActionService - OTC order processing logic', completed: false },
      { id: 'exchange-entity', title: 'Exchange order entity and repository', completed: false },
      { id: 'exchange-buy', title: 'OTC buy order creation and validation', completed: false },
      { id: 'exchange-sell', title: 'OTC sell order creation and validation', completed: false },
      { id: 'exchange-approve', title: 'Order approval logic and fund transfer', completed: false },
      { id: 'exchange-cancel', title: 'Order cancellation logic', completed: false },
      { id: 'exchange-controller', title: 'ExchangeActionController with all endpoints', completed: false },
      { id: 'exchange-dto', title: 'DTOs for OTC operations', completed: false }
    ],
    notes: [],
    dependencies: ['Level5_WalletServices'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 15: Support & Content
  Level15_SupportContent: {
    id: 'Level15_SupportContent',
    title: 'ðŸŽ® Level 15: Support & Content Management',
    description: 'Build TicketService, BlogService, FileService, MessageService, FAQService, TicketController, and BlogController for customer support and content management.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.MEDIUM,
    category: 'Services',
    estimatedHours: 40,
    actualHours: 0,
    subtasks: [
      // TicketService
      { id: 'ticket-entity', title: 'Create Ticket and TicketMessage entities', completed: false },
      { id: 'ticket-crud', title: 'Ticket CRUD operations', completed: false },
      { id: 'ticket-messages', title: 'Ticket message handling with file attachments', completed: false },
      { id: 'ticket-status', title: 'Ticket status management (OPEN, IN_PROGRESS, RESOLVED, CLOSED)', completed: false },
      { id: 'ticket-assignment', title: 'Ticket assignment to admins', completed: false },
      { id: 'ticket-priority', title: 'Ticket priority management', completed: false },
      { id: 'ticket-categories', title: 'Ticket category management', completed: false },
      { id: 'ticket-notification', title: 'Notification system for ticket updates', completed: false },
      { id: 'ticket-search', title: 'Ticket search and filtering', completed: false },
      // BlogService
      { id: 'blog-entity', title: 'BlogPost entity with all fields', completed: false },
      { id: 'blog-crud', title: 'Blog post CRUD operations', completed: false },
      { id: 'blog-content', title: 'Content management and formatting', completed: false },
      { id: 'blog-publishing', title: 'Publishing and visibility control', completed: false },
      { id: 'blog-categories', title: 'Category management', completed: false },
      { id: 'blog-seo', title: 'SEO metadata management', completed: false },
      { id: 'blog-images', title: 'Image upload and management', completed: false },
      { id: 'blog-search', title: 'Blog post search functionality', completed: false },
      // FileService
      { id: 'file-service', title: 'FileService - file upload, storage, and management', completed: false },
      { id: 'file-validation', title: 'File validation (type, size)', completed: false },
      { id: 'file-storage', title: 'File storage (local or cloud)', completed: false },
      // Controllers
      { id: 'ticket-controller', title: 'TicketController with all endpoints', completed: false },
      { id: 'blog-controller', title: 'BlogController with all endpoints', completed: false }
    ],
    notes: [],
    dependencies: ['Level2_DatabaseAuth', 'Level4_Notifications'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 16: Promotional Features
  Level16_Promotional: {
    id: 'Level16_Promotional',
    title: 'ðŸŽ® Level 16: Promotional Features',
    description: 'Build GiftCodeService, ReferralCodeService, GiftCodeController, and ReferralCodeController for gift codes, referral programs, and promotional campaigns.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.MEDIUM,
    category: 'Services',
    estimatedHours: 28,
    actualHours: 0,
    subtasks: [
      // GiftCodeService
      { id: 'gift-entity', title: 'GiftCode entity with all fields', completed: false },
      { id: 'gift-generate', title: 'Gift code generation algorithm', completed: false },
      { id: 'gift-validate', title: 'Gift code validation logic', completed: false },
      { id: 'gift-redeem', title: 'Gift code redemption logic', completed: false },
      { id: 'gift-expiration', title: 'Expiration date management', completed: false },
      { id: 'gift-limits', title: 'Usage limits and restrictions', completed: false },
      { id: 'gift-tracking', title: 'Usage tracking and statistics', completed: false },
      { id: 'gift-rewards', title: 'Reward distribution logic', completed: false },
      // ReferralCodeService
      { id: 'referral-entity', title: 'ReferralCode and ReferralRelationship entities', completed: false },
      { id: 'referral-generate', title: 'Referral code generation logic', completed: false },
      { id: 'referral-tracking', title: 'Referral relationship tracking', completed: false },
      { id: 'referral-rewards', title: 'Referral reward calculation', completed: false },
      { id: 'referral-distribution', title: 'Reward distribution logic', completed: false },
      { id: 'referral-stats', title: 'Referral statistics and analytics', completed: false },
      { id: 'referral-validation', title: 'Referral code validation', completed: false },
      // Controllers
      { id: 'gift-controller', title: 'GiftCodeController with all endpoints', completed: false },
      { id: 'referral-controller', title: 'ReferralCodeController with all endpoints', completed: false }
    ],
    notes: [],
    dependencies: ['Level3_CustomerIdentity', 'Level5_WalletServices'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 17: Additional Services
  Level17_AdditionalServices: {
    id: 'Level17_AdditionalServices',
    title: 'ðŸŽ® Level 17: Additional Services',
    description: 'Build ExchangeSettingService, CustomerTokenService, AlarmService, and other supporting services for system configuration and monitoring.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.MEDIUM,
    category: 'Services',
    estimatedHours: 20,
    actualHours: 0,
    subtasks: [
      { id: 'exchange-setting-service', title: 'ExchangeSettingService - exchange configuration management', completed: false },
      { id: 'customer-token-service', title: 'CustomerTokenService - token management for customers', completed: false },
      { id: 'alarm-service', title: 'AlarmService - system alerts and monitoring', completed: false },
      { id: 'faq-service', title: 'FAQService - FAQ management (if needed)', completed: false },
      { id: 'message-service', title: 'MessageService - internal messaging (if needed)', completed: false },
      { id: 'scheduled-tasks', title: 'Scheduled tasks setup and configuration', completed: false },
      { id: 'health-checks', title: 'Health check endpoints and monitoring', completed: false }
    ],
    notes: [],
    dependencies: ['Level2_DatabaseAuth'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  // Level 18: Testing & Documentation
  Level18_TestingDocumentation: {
    id: 'Level18_TestingDocumentation',
    title: 'ðŸŽ® Level 18: Testing & Documentation',
    description: 'Write comprehensive unit tests, integration tests, API documentation, and deployment guides for the entire system.',
    status: TaskStatus.NOT_STARTED,
    priority: TaskPriority.HIGH,
    category: 'Infrastructure',
    estimatedHours: 40,
    actualHours: 0,
    subtasks: [
      { id: 'unit-tests', title: 'Write unit tests for all services', completed: false },
      { id: 'integration-tests', title: 'Write integration tests for all controllers', completed: false },
      { id: 'e2e-tests', title: 'Write end-to-end tests for critical flows', completed: false },
      { id: 'api-docs', title: 'Complete Swagger/OpenAPI documentation', completed: false },
      { id: 'code-docs', title: 'Code documentation and comments', completed: false },
      { id: 'deployment-guide', title: 'Deployment guide and configuration', completed: false },
      { id: 'api-testing', title: 'API testing with Postman/Insomnia collections', completed: false }
    ],
    notes: [],
    dependencies: ['Level1_ProjectSetup', 'Level2_DatabaseAuth'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  }
}

// Task name mapping - maps messy node IDs to proper task names and metadata
const TASK_NAME_MAPPING = {
  // Controllers
  'AdminController': { title: 'Admin Controller', category: 'Controllers', level: 'Level13_AdminRBAC', priority: TaskPriority.HIGH },
  'CustomerController': { title: 'Customer Controller', category: 'Controllers', level: 'Level3_CustomerIdentity', priority: TaskPriority.CRITICAL },
  'OrderController': { title: 'Order Controller', category: 'Controllers', level: 'Level9_TradingControllers', priority: TaskPriority.CRITICAL },
  'WalletController': { title: 'Wallet Controller', category: 'Controllers', level: 'Level10_WalletController', priority: TaskPriority.CRITICAL },
  'TradeController': { title: 'Trade Controller', category: 'Controllers', level: 'Level9_TradingControllers', priority: TaskPriority.CRITICAL },
  'MarketController': { title: 'Market Controller', category: 'Controllers', level: 'Level8_MarketManagement', priority: TaskPriority.HIGH },
  'CoinController': { title: 'Coin Controller', category: 'Controllers', level: 'Level8_MarketManagement', priority: TaskPriority.HIGH },
  'ExchangeActionController': { title: 'Exchange Action Controller', category: 'Controllers', level: 'Level14_OTCExchange', priority: TaskPriority.HIGH },
  'TicketController': { title: 'Ticket Controller', category: 'Controllers', level: 'Level15_SupportContent', priority: TaskPriority.MEDIUM },
  'BlogController': { title: 'Blog Controller', category: 'Controllers', level: 'Level15_SupportContent', priority: TaskPriority.MEDIUM },
  'GiftCodeController': { title: 'Gift Code Controller', category: 'Controllers', level: 'Level16_Promotional', priority: TaskPriority.MEDIUM },
  'ReferralCodeController': { title: 'Referral Code Controller', category: 'Controllers', level: 'Level16_Promotional', priority: TaskPriority.MEDIUM },
  'RolesController': { title: 'Roles Controller', category: 'Controllers', level: 'Level13_AdminRBAC', priority: TaskPriority.HIGH },
  'FinoTechController': { title: 'FinoTech Controller', category: 'Controllers', level: 'Level12_KYCIdentity', priority: TaskPriority.HIGH },
  'JibitController': { title: 'Jibit Controller', category: 'Controllers', level: 'Level12_KYCIdentity', priority: TaskPriority.HIGH },
  'AlarmController': { title: 'Alarm Controller', category: 'Controllers', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'FileController': { title: 'File Controller', category: 'Controllers', level: 'Level15_SupportContent', priority: TaskPriority.MEDIUM },
  'LanguageController': { title: 'Language Controller', category: 'Controllers', level: 'Level17_AdditionalServices', priority: TaskPriority.LOW },
  'CountryController': { title: 'Country Controller', category: 'Controllers', level: 'Level17_AdditionalServices', priority: TaskPriority.LOW },
  'ExchangeController': { title: 'Exchange Controller', category: 'Controllers', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'ExchangeSettingController': { title: 'Exchange Setting Controller', category: 'Controllers', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'HealthController': { title: 'Health Controller', category: 'Controllers', level: 'Level17_AdditionalServices', priority: TaskPriority.LOW },
  'VandarWebhookController': { title: 'Vandar Webhook Controller', category: 'Controllers', level: 'Level11_PaymentGateways', priority: TaskPriority.HIGH },
  'AtmController': { title: 'ATM Controller', category: 'Controllers', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'CreditCardController': { title: 'Credit Card Controller', category: 'Controllers', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'SaminCardController': { title: 'Samin Card Controller', category: 'Controllers', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'SocketController': { title: 'Socket Controller', category: 'Controllers', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  
  // Services
  'AdminService': { title: 'Admin Service', category: 'Services', level: 'Level13_AdminRBAC', priority: TaskPriority.HIGH },
  'CustomerService': { title: 'Customer Service', category: 'Services', level: 'Level3_CustomerIdentity', priority: TaskPriority.CRITICAL },
  'OrderService': { title: 'Order Service', category: 'Services', level: 'Level7_TradingEngine', priority: TaskPriority.CRITICAL },
  'WalletService': { title: 'Wallet Service', category: 'Services', level: 'Level5_WalletServices', priority: TaskPriority.CRITICAL },
  'TradeService': { title: 'Trade Service', category: 'Services', level: 'Level7_TradingEngine', priority: TaskPriority.CRITICAL },
  'MarketService': { title: 'Market Service', category: 'Services', level: 'Level8_MarketManagement', priority: TaskPriority.HIGH },
  'CoinService': { title: 'Coin Service', category: 'Services', level: 'Level8_MarketManagement', priority: TaskPriority.HIGH },
  'ApieService': { title: 'Apie Service (Blockchain)', category: 'Services', level: 'Level6_Blockchain', priority: TaskPriority.CRITICAL },
  'GiftCodeService': { title: 'Gift Code Service', category: 'Services', level: 'Level16_Promotional', priority: TaskPriority.MEDIUM },
  'ReferralCodeService': { title: 'Referral Code Service', category: 'Services', level: 'Level16_Promotional', priority: TaskPriority.MEDIUM },
  'TicketService': { title: 'Ticket Service', category: 'Services', level: 'Level15_SupportContent', priority: TaskPriority.MEDIUM },
  'BlogService': { title: 'Blog Service', category: 'Services', level: 'Level15_SupportContent', priority: TaskPriority.MEDIUM },
  'FileService': { title: 'File Service', category: 'Services', level: 'Level15_SupportContent', priority: TaskPriority.MEDIUM },
  'EmailService': { title: 'Email Service', category: 'Services', level: 'Level4_Notifications', priority: TaskPriority.HIGH },
  'SMSService': { title: 'SMS Service', category: 'Services', level: 'Level4_Notifications', priority: TaskPriority.HIGH },
  'NotificationService': { title: 'Notification Service', category: 'Services', level: 'Level4_Notifications', priority: TaskPriority.HIGH },
  'CustomerWalletService': { title: 'Customer Wallet Service', category: 'Services', level: 'Level5_WalletServices', priority: TaskPriority.CRITICAL },
  'DepositService': { title: 'Deposit Service', category: 'Services', level: 'Level5_WalletServices', priority: TaskPriority.CRITICAL },
  'WithdrawalRequestService': { title: 'Withdrawal Service', category: 'Services', level: 'Level5_WalletServices', priority: TaskPriority.CRITICAL },
  'FinoTechService': { title: 'FinoTech Service', category: 'Services', level: 'Level12_KYCIdentity', priority: TaskPriority.HIGH },
  'JibitService': { title: 'Jibit Service', category: 'Services', level: 'Level12_KYCIdentity', priority: TaskPriority.HIGH },
  'BankAccountService': { title: 'Bank Account Service', category: 'Services', level: 'Level12_KYCIdentity', priority: TaskPriority.HIGH },
  'UserAccountLevelService': { title: 'User Account Level Service', category: 'Services', level: 'Level12_KYCIdentity', priority: TaskPriority.HIGH },
  'RoleService': { title: 'Role Service', category: 'Services', level: 'Level13_AdminRBAC', priority: TaskPriority.HIGH },
  'ExchangeActionService': { title: 'Exchange Action Service', category: 'Services', level: 'Level14_OTCExchange', priority: TaskPriority.HIGH },
  'ExchangeSettingService': { title: 'Exchange Setting Service', category: 'Services', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'CustomerTokenService': { title: 'Customer Token Service', category: 'Services', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'AlarmService': { title: 'Alarm Service', category: 'Services', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'MessageService': { title: 'Message Service', category: 'Services', level: 'Level15_SupportContent', priority: TaskPriority.MEDIUM },
  'FAQService': { title: 'FAQ Service', category: 'Services', level: 'Level15_SupportContent', priority: TaskPriority.LOW },
  'CountryService': { title: 'Country Service', category: 'Services', level: 'Level17_AdditionalServices', priority: TaskPriority.LOW },
  'LanguageService': { title: 'Language Service', category: 'Services', level: 'Level17_AdditionalServices', priority: TaskPriority.LOW },
  'AtmService': { title: 'ATM Service', category: 'Services', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'CreditCardService': { title: 'Credit Card Service', category: 'Services', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'SaminCardService': { title: 'Samin Card Service', category: 'Services', level: 'Level17_AdditionalServices', priority: TaskPriority.MEDIUM },
  'TomanTransactionService': { title: 'Toman Transaction Service', category: 'Services', level: 'Level5_WalletServices', priority: TaskPriority.MEDIUM },
  'CashDepositService': { title: 'Cash Deposit Service', category: 'Services', level: 'Level5_WalletServices', priority: TaskPriority.MEDIUM },
  
  // Clean up common messy patterns
  'Order ServiceervicecreateOrder deleteOrdergetOrder Book validateDTO': { title: 'Order Service', category: 'Services', level: 'Level7_TradingEngine', priority: TaskPriority.CRITICAL },
  'Jibit ServiceervicematchIBAN matchCardidentitySimilarity': { title: 'Jibit Service', category: 'Services', level: 'Level12_KYCIdentity', priority: TaskPriority.HIGH },
  'Vandar Serviceervice': { title: 'Vandar Payment Gateway', category: 'Services', level: 'Level11_PaymentGateways', priority: TaskPriority.HIGH },
  'Deposit ServiceervicetrackDeposit confirmDeposit': { title: 'Deposit Service', category: 'Services', level: 'Level5_WalletServices', priority: TaskPriority.CRITICAL },
  'Customer Wallet ServiceervicegetBalance updateBalancelockFunds unlockFunds': { title: 'Customer Wallet Service', category: 'Services', level: 'Level5_WalletServices', priority: TaskPriority.CRITICAL },
  'Withdrawal ServiceervicecreateRequestapproveWithdrawalr': { title: 'Withdrawal Service', category: 'Services', level: 'Level5_WalletServices', priority: TaskPriority.CRITICAL },
  'Wallet ServiceervicecreateHDWalletgenerate Addresscr': { title: 'Wallet Service', category: 'Services', level: 'Level5_WalletServices', priority: TaskPriority.CRITICAL },
  'FinoTech Serviceervicevalidate NationallDcard TolBAN sendSMSverifyBankAccount': { title: 'FinoTech Service', category: 'Services', level: 'Level12_KYCIdentity', priority: TaskPriority.HIGH },
  'Controllerustomer Serviceregister authenticateupdateProfile manageKYC': { title: 'Customer Service', category: 'Services', level: 'Level3_CustomerIdentity', priority: TaskPriority.CRITICAL },
}

// Helper to extract individual names from messy concatenated strings
const extractNamesFromMessyId = (taskId) => {
  // Remove common patterns
  let cleaned = taskId
    .replace(/Development/g, '')
    .replace(/Serviceervice/g, 'Service')
    .replace(/Controllerustomer/g, 'Controller')
    .trim()
  
  // Split by common patterns: camelCase boundaries, spaces, and common words
  const names = []
  let current = ''
  
  // Pattern to detect camelCase boundaries and method names
  const camelCasePattern = /([a-z])([A-Z])/g
  cleaned = cleaned.replace(camelCasePattern, '$1 $2')
  
  // Split by spaces and filter empty
  const parts = cleaned.split(/\s+/).filter(p => p.length > 0)
  
  // Group parts into logical names
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i]
    
    // If it's a service/controller name, start a new group
    if (part.endsWith('Service') || part.endsWith('Controller')) {
      if (current) {
        names.push(current.trim())
        current = ''
      }
      names.push(part)
    }
    // If it's a method name (starts with lowercase or is camelCase), add to current
    else if (/^[a-z]/.test(part) || /^[a-z][A-Z]/.test(part)) {
      if (current && !current.endsWith('Service') && !current.endsWith('Controller')) {
        current += ' ' + part
      } else {
        if (current) names.push(current.trim())
        current = part
      }
    }
    // Otherwise, it's probably part of the current name
    else {
      current += (current ? ' ' : '') + part
    }
  }
  
  if (current) {
    names.push(current.trim())
  }
  
  return names.filter(n => n.length > 0)
}

// Helper to get a short, clean title from messy ID
const getShortTitle = (taskId, extractedNames) => {
  // Try exact match first
  if (TASK_NAME_MAPPING[taskId]) {
    return TASK_NAME_MAPPING[taskId].title
  }
  
  // Find the main service/controller name
  const mainName = extractedNames.find(n => 
    n.endsWith('Service') || n.endsWith('Controller')
  )
  
  if (mainName) {
    // Try to match it in our mapping
    if (TASK_NAME_MAPPING[mainName]) {
      return TASK_NAME_MAPPING[mainName].title
    }
    // Otherwise format it nicely
    return mainName.replace(/([A-Z])/g, ' $1').trim()
  }
  
  // If no main name found, use the first extracted name
  if (extractedNames.length > 0) {
    return extractedNames[0].replace(/([A-Z])/g, ' $1').trim()
  }
  
  // Last resort: format the original ID
  return taskId
    .replace(/Serviceervice/g, 'Service')
    .replace(/Controllerustomer/g, 'Controller')
    .replace(/Development/g, '')
    .replace(/([a-z])([A-Z])/g, '$1 $2')
    .replace(/\s+/g, ' ')
    .trim()
    .split(' ')[0] // Take first word only
}

// Helper to create subtasks from extracted names
const createSubtasksFromNames = (taskId, extractedNames, mainTitle) => {
  const subtasks = []
  
  // Find the main service/controller
  const mainName = extractedNames.find(n => 
    n.endsWith('Service') || n.endsWith('Controller')
  )
  
  // Get method/function names (everything except the main name)
  const methodNames = extractedNames.filter(n => 
    n !== mainName && 
    !n.endsWith('Service') && 
    !n.endsWith('Controller') &&
    n.length > 0
  )
  
  // Always add standard subtasks
  subtasks.push(
    { id: `${taskId}-entity`, title: `Create entity and repository`, completed: false },
    { id: `${taskId}-service`, title: `Implement service logic`, completed: false },
    { id: `${taskId}-controller`, title: `Create controller with endpoints`, completed: false },
    { id: `${taskId}-dto`, title: `Create DTOs`, completed: false },
    { id: `${taskId}-validation`, title: `Add validation and error handling`, completed: false }
  )
  
  // Add subtasks for each method/function found
  methodNames.forEach((methodName, idx) => {
    const cleanMethod = methodName
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .trim()
    subtasks.push({
      id: `${taskId}-method-${idx}`,
      title: `Implement ${cleanMethod} functionality`,
      completed: false
    })
  })
  
  // Add test subtask at the end
  subtasks.push({ id: `${taskId}-tests`, title: `Write tests`, completed: false })
  
  return subtasks
}

// Helper to clean up messy task IDs and get proper metadata
const getTaskMetadata = (taskId) => {
  // Try exact match first
  if (TASK_NAME_MAPPING[taskId]) {
    return TASK_NAME_MAPPING[taskId]
  }
  
  // Extract individual names from messy ID
  const extractedNames = extractNamesFromMessyId(taskId)
  
  // Get short title
  const shortTitle = getShortTitle(taskId, extractedNames)
  
  // Try to find matching service/controller in mapping
  const mainName = extractedNames.find(n => 
    n.endsWith('Service') || n.endsWith('Controller')
  )
  
  let metadata = null
  if (mainName && TASK_NAME_MAPPING[mainName]) {
    metadata = TASK_NAME_MAPPING[mainName]
  }
  
  // Determine category
  let category = 'Other'
  if (mainName) {
    if (mainName.endsWith('Controller')) category = 'Controllers'
    else if (mainName.endsWith('Service')) category = 'Services'
  }
  
  // Determine priority based on name
  let priority = TaskPriority.MEDIUM
  if (mainName) {
    const criticalServices = ['OrderService', 'TradeService', 'WalletService', 'CustomerService', 'ApieService']
    const highServices = ['AdminService', 'MarketService', 'CoinService', 'DepositService', 'WithdrawalRequestService']
    if (criticalServices.some(s => mainName.includes(s))) priority = TaskPriority.CRITICAL
    else if (highServices.some(s => mainName.includes(s))) priority = TaskPriority.HIGH
  }
  
  return {
    title: shortTitle,
    category: metadata?.category || category,
    level: metadata?.level || null,
    priority: metadata?.priority || priority,
    extractedNames,
    originalId: taskId
  }
}

// Helper to transform backend task to frontend format
const transformBackendTask = (backendTask) => {
  return {
    id: backendTask.nodeId,
    nodeId: backendTask.nodeId,
    title: backendTask.title,
    description: backendTask.description || '',
    status: backendTask.status,
    priority: TaskPriority.MEDIUM,
    category: 'Other',
    estimatedHours: backendTask.estimatedHours || 0,
    actualHours: backendTask.actualHours || 0,
    subtasks: Array.isArray(backendTask.subtasks) 
      ? backendTask.subtasks.map((st, idx) => ({
          id: st.id || `subtask-${idx}`,
          title: typeof st === 'string' ? st : st.title,
          completed: typeof st === 'object' ? st.completed : false
        }))
      : [],
    notes: backendTask.notes ? (Array.isArray(backendTask.notes) ? backendTask.notes : [backendTask.notes]) : [],
    dependencies: Array.isArray(backendTask.dependencies) ? backendTask.dependencies : [],
    createdAt: backendTask.createdAt,
    updatedAt: backendTask.updatedAt,
    backendId: backendTask.id
  }
}

// Helper to transform frontend task to backend format
const transformFrontendTask = (frontendTask) => {
  return {
    nodeId: frontendTask.nodeId || frontendTask.id,
    title: frontendTask.title,
    description: frontendTask.description || '',
    status: frontendTask.status || TaskStatus.NOT_STARTED,
    notes: Array.isArray(frontendTask.notes) 
      ? frontendTask.notes.map(n => typeof n === 'string' ? n : n.content).join('\n')
      : frontendTask.notes || '',
    estimatedHours: frontendTask.estimatedHours || 0,
    actualHours: frontendTask.actualHours || 0,
    subtasks: frontendTask.subtasks || [],
    dependencies: frontendTask.dependencies || []
  }
}

// Helper to extract base service/controller name from task
const getBaseName = (taskId, title) => {
  // Try to extract clean service/controller name
  const cleanId = taskId
    .replace(/Serviceervice/g, 'Service')
    .replace(/Controllerustomer/g, 'Controller')
    .replace(/Development/g, '')
    .trim()
  
  // Match common patterns
  const serviceMatch = cleanId.match(/(\w+Service)/i)
  const controllerMatch = cleanId.match(/(\w+Controller)/i)
  
  if (serviceMatch) return serviceMatch[1]
  if (controllerMatch) return controllerMatch[1]
  
  // Try from title
  if (title) {
    const titleService = title.match(/(\w+)\s+Service/i)
    const titleController = title.match(/(\w+)\s+Controller/i)
    if (titleService) return titleService[1] + 'Service'
    if (titleController) return titleController[1] + 'Controller'
  }
  
  return null
}

// Helper to merge duplicate tasks
const mergeDuplicateTasks = (tasks) => {
  const merged = {}
  const taskGroups = {} // Groups tasks by base name
  const tasksToRemove = new Set()
  
  // First pass: group tasks by base name
  Object.keys(tasks).forEach(taskId => {
    // Skip level tasks
    if (taskId.startsWith('Level')) {
      merged[taskId] = tasks[taskId]
      return
    }
    
    const task = tasks[taskId]
    if (!task) return
    
    const baseName = getBaseName(taskId, task.title)
    
    if (!baseName) {
      // Keep tasks without clear base name (might be unique)
      merged[taskId] = task
      return
    }
    
    if (!taskGroups[baseName]) {
      taskGroups[baseName] = []
    }
    taskGroups[baseName].push({ taskId, task })
  })
  
  // Second pass: merge groups
  Object.keys(taskGroups).forEach(baseName => {
    const group = taskGroups[baseName]
    
    if (group.length === 1) {
      // Single task, keep as is
      merged[group[0].taskId] = group[0].task
      return
    }
    
    // Multiple tasks - merge them
    // Find the best task to keep (prefer clean names, higher priority)
    group.sort((a, b) => {
      const aClean = !a.taskId.includes('Serviceervice') && !a.taskId.includes('Controllerustomer')
      const bClean = !b.taskId.includes('Serviceervice') && !b.taskId.includes('Controllerustomer')
      if (aClean !== bClean) return aClean ? -1 : 1
      
      const aPriority = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].indexOf(a.task.priority?.toUpperCase() || 'MEDIUM')
      const bPriority = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].indexOf(b.task.priority?.toUpperCase() || 'MEDIUM')
      return aPriority - bPriority
    })
    
    const primaryTask = group[0]
    const otherTasks = group.slice(1)
    
    // Determine if we should merge Controller + Service
    const hasController = group.some(t => t.task.category === 'Controllers' || t.taskId.includes('Controller'))
    const hasService = group.some(t => t.task.category === 'Services' || t.taskId.includes('Service'))
    
    if (hasController && hasService) {
      // Merge Controller + Service into one task
      const controllerTask = group.find(t => t.task.category === 'Controllers' || t.taskId.includes('Controller'))
      const serviceTask = group.find(t => t.task.category === 'Services' || t.taskId.includes('Service'))
      
      const mergedTask = {
        ...(controllerTask || serviceTask || primaryTask).task,
        id: baseName,
        nodeId: baseName,
        title: baseName.replace(/([A-Z])/g, ' $1').trim(),
        description: `Migrate ${baseName} (both Service and Controller) to NestJS architecture. This includes the service layer with business logic and the controller layer with REST endpoints.`,
        category: 'Services', // Services are more fundamental
        priority: primaryTask.task.priority || TaskPriority.MEDIUM,
        subtasks: [
          // Service subtasks
          { id: `${baseName}-service-entity`, title: `Create ${baseName} entity and repository`, completed: false },
          { id: `${baseName}-service-logic`, title: `Implement ${baseName} service logic`, completed: false },
          { id: `${baseName}-service-methods`, title: `Implement all service methods`, completed: false },
          // Controller subtasks
          { id: `${baseName}-controller-module`, title: `Create ${baseName} controller module`, completed: false },
          { id: `${baseName}-controller-endpoints`, title: `Implement all controller endpoints`, completed: false },
          { id: `${baseName}-controller-dto`, title: `Create DTOs for ${baseName}`, completed: false },
          { id: `${baseName}-controller-validation`, title: `Add validation and error handling`, completed: false },
          { id: `${baseName}-tests`, title: `Write tests for ${baseName}`, completed: false }
        ],
        notes: [
          ...(controllerTask?.task.notes || []),
          ...(serviceTask?.task.notes || []),
          ...otherTasks.flatMap(t => t.task.notes || [])
        ],
        updatedAt: new Date().toISOString()
      }
      
      // Add subtasks from other tasks
      otherTasks.forEach(({ task }) => {
        if (task.subtasks && task.subtasks.length > 0) {
          task.subtasks.forEach(subtask => {
            if (!mergedTask.subtasks.find(st => st.title === subtask.title)) {
              mergedTask.subtasks.push({
                ...subtask,
                id: `${baseName}-${subtask.id}`
              })
            }
          })
        }
      })
      
      merged[baseName] = mergedTask
      
      // Mark other tasks for removal
      group.forEach(({ taskId }) => {
        if (taskId !== baseName) {
          tasksToRemove.add(taskId)
        }
      })
    } else {
      // Same type (all controllers or all services) - merge into one
      const mergedTask = {
        ...primaryTask.task,
        id: baseName,
        nodeId: baseName,
        title: baseName.replace(/([A-Z])/g, ' $1').trim(),
        description: `Migrate ${baseName} to NestJS architecture. This involves translating the Java Spring Boot implementation to NestJS TypeScript, maintaining all functionality, endpoints, and business logic.`,
        subtasks: [...(primaryTask.task.subtasks || [])],
        notes: [...(primaryTask.task.notes || [])],
        updatedAt: new Date().toISOString()
      }
      
      // Merge subtasks from other tasks
      otherTasks.forEach(({ task }) => {
        if (task.subtasks && task.subtasks.length > 0) {
          task.subtasks.forEach(subtask => {
            if (!mergedTask.subtasks.find(st => st.title === subtask.title)) {
              mergedTask.subtasks.push({
                ...subtask,
                id: `${baseName}-${subtask.id}`
              })
            }
          })
        }
        if (task.notes && task.notes.length > 0) {
          mergedTask.notes.push(...task.notes)
        }
      })
      
      merged[baseName] = mergedTask
      
      // Mark other tasks for removal
      otherTasks.forEach(({ taskId }) => {
        tasksToRemove.add(taskId)
      })
    }
  })
  
  return { merged, tasksToRemove }
}

// Helper to remove useless tasks
const removeUselessTasks = (tasks) => {
  const cleaned = { ...tasks }
  const uselessPatterns = [
    /^test/i,
    /^debug/i,
    /^sample/i,
    /^example/i,
    /Development$/i,
    /^ff$/i,
    /^CLIENTSWeb$/i,
    /^account_wallets$/i,
    /^customer_wallet$/i,
    /^customers admins login_histories$/i,
    /^ROLE PRIVILEGE roles_privileges$/i,
    /^finno_tech_validation bank_accounts credit_card$/i,
    /^Web Mobile UI$/i,
    /^internal_transaction$/i,
    /^tron_transactions$/i,
    /^deposit_requests$/i,
    /^toman_transactions$/i,
    /^withdrawal_requests$/i,
    /^hd_wallet$/i,
    /^hd_wallet_address$/i,
    /^2FA OTP$/i,
    /^Auth Manager$/i,
    /^JWT Auth$/i,
    /^Webhooks$/i,
    /^Payment Gateways$/i,
    /^ATM Devices$/i,
    /^blog faq user_manual$/i,
    /^ethereum_transaction$/i,
    /^Multi-Chain SupportETH ERC20TRON TRC20BTC XRP XLM BSC BEP20$/i,
    /^Authentication$/i,
    /^Deposit Handling Webhook callbacks Gateway updates$/i,
    /^KYC APIs$/i,
    /^Payment APIs$/i,
    /^Blockchain APIs$/i,
    /^Select KYC provider$/i,
    /^Validate NID$/i,
    /^Match IBAN$/i,
    /^Admin review$/i,
    /^Approved\?$/i,
    /^Update to AUTHORIZED$/i
  ]
  
  Object.keys(cleaned).forEach(taskId => {
    // Skip level tasks
    if (taskId.startsWith('Level')) return
    
    const task = cleaned[taskId]
    if (!task) return
    
    // Check if task matches useless patterns
    const isUseless = uselessPatterns.some(pattern => 
      pattern.test(taskId) || (task.title && pattern.test(task.title))
    )
    
    // Also check for very low priority tasks that are likely duplicates
    const isLowPriorityDuplicate = task.priority === TaskPriority.LOW && 
                                   (taskId.length > 50 || task.title?.length > 50)
    
    if (isUseless || isLowPriorityDuplicate) {
      delete cleaned[taskId]
    }
  })
  
  return cleaned
}

// Helper to clean up existing tasks with messy names
const cleanupTaskNames = (tasks) => {
  // Step 1: Clean up messy names
  let cleaned = { ...tasks }
  
  Object.keys(cleaned).forEach(taskId => {
    // Skip level tasks
    if (taskId.startsWith('Level')) return
    
    const task = cleaned[taskId]
    if (!task) return
    
    // Check if task has a messy name (contains "Serviceervice" or similar patterns)
    const hasMessyName = taskId.includes('Serviceervice') || 
                         taskId.includes('Controllerustomer') ||
                         task.title?.includes('Serviceervice') ||
                         (task.title && task.title.length > 50 && !task.title.startsWith('ðŸŽ®'))
    
    if (hasMessyName) {
      // Get proper metadata
      const metadata = getTaskMetadata(taskId)
      
      // Update task with clean name and proper structure
      cleaned[taskId] = {
        ...task,
        title: metadata.title,
        description: task.description || `Migrate ${metadata.title} to NestJS architecture. This involves translating the Java Spring Boot implementation to NestJS TypeScript, maintaining all functionality, endpoints, and business logic.\n\nOriginal identifier: ${taskId}`,
        category: metadata.category || task.category,
        priority: metadata.priority || task.priority,
        subtasks: task.subtasks && task.subtasks.length > 0 
          ? task.subtasks 
          : createSubtasksFromNames(taskId, metadata.extractedNames || [], metadata.title),
        updatedAt: new Date().toISOString()
      }
    }
  })
  
  // Step 2: Remove useless tasks
  cleaned = removeUselessTasks(cleaned)
  
  // Step 3: Merge duplicate tasks
  const { merged, tasksToRemove } = mergeDuplicateTasks(cleaned)
  
  // Remove merged tasks
  tasksToRemove.forEach(taskId => {
    delete merged[taskId]
  })
  
  return merged
}

export const TodoProvider = ({ children }) => {
  const [tasks, setTasks] = useState(() => {
    const saved = localStorage.getItem('bitnitex-project-tasks')
    const loadedTasks = saved ? JSON.parse(saved) : DEFAULT_TASKS
    // Clean up messy task names on load
    return cleanupTaskNames(loadedTasks)
  })

  const [showTodoPanel, setShowTodoPanel] = useState(false)
  const [selectedTask, setSelectedTask] = useState(null)
  const [filterStatus, setFilterStatus] = useState(null)
  const [filterCategory, setFilterCategory] = useState(null)
  const [loading, setLoading] = useState(false)
  const [useBackend, setUseBackend] = useState(false) // Disabled temporarily - using new 18-level structure
  const [backendError, setBackendError] = useState(null)

  // Load tasks from backend on mount
  useEffect(() => {
    if (useBackend) {
      loadTasksFromBackend()
    }
  }, [useBackend])

  const loadTasksFromBackend = async () => {
    try {
      setLoading(true)
      setBackendError(null)
      const response = await fetch('http://localhost:3001/api/tasks')
      if (!response.ok) throw new Error('Failed to load tasks')
      const backendTasks = await response.json()
      
      // Transform backend tasks and merge with defaults
      const transformedTasks = {}
      backendTasks.forEach(bt => {
        transformedTasks[bt.nodeId] = transformBackendTask(bt)
      })
      
      // Merge with defaults (backend takes precedence)
      const mergedTasks = { ...DEFAULT_TASKS, ...transformedTasks }
      setTasks(mergedTasks)
    } catch (error) {
      console.error('Failed to load tasks from backend:', error)
      setBackendError(error.message)
      // Fallback to localStorage if backend fails
      const saved = localStorage.getItem('bitnitex-project-tasks')
      if (saved) {
        setTasks(JSON.parse(saved))
      }
    } finally {
      setLoading(false)
    }
  }

  const saveTaskToBackend = async (task) => {
    if (!useBackend) return
    
    try {
      const backendTask = transformFrontendTask(task)
      const url = task.backendId 
        ? `http://localhost:3001/api/tasks/${task.backendId}`
        : 'http://localhost:3001/api/tasks'
      
      const method = task.backendId ? 'PUT' : 'POST'
      
      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(backendTask)
      })
      
      if (!response.ok) throw new Error('Failed to save task')
      return await response.json()
    } catch (error) {
      console.error('Failed to save task to backend:', error)
      throw error
    }
  }

  const updateTask = (taskId, updates) => {
    setTasks(prev => {
      let updated = {
        ...prev,
        [taskId]: {
          ...prev[taskId],
          ...updates,
          updatedAt: new Date().toISOString()
        }
      }
      
      // Periodically clean up and merge tasks (every 10 updates or so)
      // This ensures duplicates get merged over time
      const shouldCleanup = Math.random() < 0.1 // 10% chance on each update
      if (shouldCleanup) {
        updated = cleanupTaskNames(updated)
      }
      
      // Save to localStorage
      localStorage.setItem('bitnitex-project-tasks', JSON.stringify(updated))
      
      // Save to backend if enabled
      if (useBackend && updated[taskId]) {
        saveTaskToBackend(updated[taskId]).catch(err => {
          console.error('Backend save failed, using localStorage only:', err)
        })
      }
      
      return updated
    })
  }

  const updateSubtask = (taskId, subtaskId, updates) => {
    setTasks(prev => {
      const task = prev[taskId]
      if (!task) return prev
      
      const updatedSubtasks = task.subtasks.map(st =>
        st.id === subtaskId ? { ...st, ...updates } : st
      )
      
      return {
        ...prev,
        [taskId]: {
          ...task,
          subtasks: updatedSubtasks,
          updatedAt: new Date().toISOString()
        }
      }
    })
  }

  const addSubtask = (taskId, subtask) => {
    setTasks(prev => {
      const task = prev[taskId]
      if (!task) return prev
      
      const newSubtask = {
        id: subtask.id || `subtask-${Date.now()}`,
        title: subtask.title || subtask,
        completed: false,
        ...(typeof subtask === 'object' ? subtask : {})
      }
      
      return {
        ...prev,
        [taskId]: {
          ...task,
          subtasks: [...(task.subtasks || []), newSubtask],
          updatedAt: new Date().toISOString()
        }
      }
    })
  }

  const toggleSubtask = (taskId, subtaskId) => {
    setTasks(prev => {
      const task = prev[taskId]
      if (!task) return prev
      
      const updatedSubtasks = task.subtasks.map(st =>
        st.id === subtaskId ? { ...st, completed: !st.completed } : st
      )
      
      return {
        ...prev,
        [taskId]: {
          ...task,
          subtasks: updatedSubtasks,
          updatedAt: new Date().toISOString()
        }
      }
    })
  }

  const updateActualHours = (taskId, hours) => {
    setTasks(prev => {
      const task = prev[taskId]
      if (!task) return prev
      
      return {
        ...prev,
        [taskId]: {
          ...task,
          actualHours: hours,
          updatedAt: new Date().toISOString()
        }
      }
    })
  }

  const updateTaskStatus = (taskId, status) => {
    updateTask(taskId, { status })
  }

  const updateTaskPriority = (taskId, priority) => {
    updateTask(taskId, { priority })
  }

  const getOrCreateTask = async (taskId) => {
    if (!taskId) return null
    
    // Check if task exists
    if (tasks[taskId]) {
      return tasks[taskId]
    }
    
    // Check if it's a level task
    if (taskId.startsWith('Level')) {
      return tasks[taskId] || null
    }
    
    // Check if a merged task exists for this base name
    const baseName = getBaseName(taskId, null)
    if (baseName && tasks[baseName]) {
      return tasks[baseName]
    }
    
    // Get proper metadata for this task
    const metadata = getTaskMetadata(taskId)
    
    // Use base name as ID if we have one, otherwise use taskId
    const finalTaskId = baseName || taskId
    
    // Check again with final ID
    if (tasks[finalTaskId]) {
      return tasks[finalTaskId]
    }
    
    // Create description with original messy name included
    const originalNameNote = metadata.originalId && metadata.originalId !== taskId 
      ? `\n\nOriginal identifier: ${metadata.originalId}`
      : ''
    
    const description = `Migrate ${metadata.title} to NestJS architecture. This involves translating the Java Spring Boot implementation to NestJS TypeScript, maintaining all functionality, endpoints, and business logic.${originalNameNote}`
    
    // Create subtasks from extracted names
    const subtasks = createSubtasksFromNames(finalTaskId, metadata.extractedNames || [], metadata.title)
    
    // Create a proper task structure with metadata
    const newTask = {
      id: finalTaskId,
      nodeId: taskId, // Keep original nodeId for reference
      title: metadata.title,
      description: description,
      status: TaskStatus.NOT_STARTED,
      priority: metadata.priority,
      category: metadata.category,
      estimatedHours: metadata.priority === TaskPriority.CRITICAL ? 16 : metadata.priority === TaskPriority.HIGH ? 12 : 8,
      actualHours: 0,
      subtasks: subtasks,
      notes: [],
      dependencies: metadata.level ? [metadata.level] : [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }
    
    setTasks(prev => ({
      ...prev,
      [finalTaskId]: newTask
    }))
    
    return newTask
  }

  const addNote = (taskId, note) => {
    setTasks(prev => {
      const task = prev[taskId]
      if (!task) return prev
      
      return {
        ...prev,
        [taskId]: {
          ...task,
          notes: [...(task.notes || []), { content: note, createdAt: new Date().toISOString() }],
          updatedAt: new Date().toISOString()
        }
      }
    })
  }

  const getProgress = () => {
    const allTasks = Object.values(tasks).filter(t => t && t.id) // Filter out null/undefined tasks
    const total = allTasks.length
    const completed = allTasks.filter(t => t.status === TaskStatus.COMPLETED).length
    const inProgress = allTasks.filter(t => t.status === TaskStatus.IN_PROGRESS).length
    const notStarted = allTasks.filter(t => t.status === TaskStatus.NOT_STARTED).length
    const blocked = allTasks.filter(t => t.status === TaskStatus.BLOCKED).length
    
    const totalSubtasks = allTasks.reduce((sum, t) => sum + (t.subtasks?.length || 0), 0)
    const completedSubtasks = allTasks.reduce((sum, t) => 
      sum + (t.subtasks?.filter(st => st.completed).length || 0), 0
    )
    
    return {
      total,
      completed,
      inProgress,
      notStarted,
      blocked,
      percentage: total > 0 ? Math.round((completed / total) * 100) : 0,
      subtasks: {
        total: totalSubtasks,
        completed: completedSubtasks,
        percentage: totalSubtasks > 0 ? Math.round((completedSubtasks / totalSubtasks) * 100) : 0
      }
    }
  }

  const getCategoryProgress = (category) => {
    const categoryTasks = Object.values(tasks).filter(t => t.category === category)
    if (categoryTasks.length === 0) {
      return { total: 0, completed: 0, percentage: 0 }
    }
    
    const total = categoryTasks.length
    const completed = categoryTasks.filter(t => t.status === TaskStatus.COMPLETED).length
    
    return {
      total,
      completed,
      percentage: total > 0 ? Math.round((completed / total) * 100) : 0
    }
  }

  const value = {
    tasks,
    updateTask,
    updateSubtask,
    addSubtask,
    toggleSubtask,
    addNote,
    updateActualHours,
    updateTaskStatus,
    updateTaskPriority,
    getProgress,
    getCategoryProgress,
    getOrCreateTask,
    showTodoPanel,
    setShowTodoPanel,
    selectedTask,
    setSelectedTask,
    filterStatus,
    setFilterStatus,
    filterCategory,
    setFilterCategory,
    loading,
    useBackend,
    setUseBackend,
    backendError,
    loadTasksFromBackend
  }

  return <TodoContext.Provider value={value}>{children}</TodoContext.Provider>
}

const TodoContext = createContext()

export const useTodoStore = () => {
  const context = useContext(TodoContext)
  if (!context) {
    throw new Error('useTodoStore must be used within TodoProvider')
  }
  return context
}
